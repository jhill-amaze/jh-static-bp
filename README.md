# static-bp

A minimalistic, modular frontend boilerplate to be used as a starting point for static site and component library builds, made with up to date tooling for 2019.


## Node version

Built for `10.x.x`.
Tested working with
```
8.9.4
```


## Operating systems

The boilerplate was built on Windows, but the aim is for it to work smoothly on all major operating systems (Windows, Mac OS, Linux). So far it has been tested working on:

```
Windows 10 Pro
Windows 8.1 Pro
```


## Setup guide

1. `cd static-bp/`
2. `npm run setup`


## Usage guide

development task: `npm run dev`
or
production task: `npm run prod`


## Goals

Knowing the goals that informed the boilerplate's creation will hopefully make it easier to understand the decisionmaking behind the boilerplate's implementation. These are:


### Practicality

The boilerplate is designed for real-world use where a job needs to get done with limited time and in imperfect conditions, as efficiently and painlessly as possible. This is the primary goal from which all other goals are derived.


### Modularity

Any system that fails can be replaced with a new equivalent with a minimum of disruption to other systems. In the real world things go wrong all the time. Dependencies break, deprecation happens, requirements change. The boilerplate attempts to accept this and plan for it instead of trying to prevent it.


### Simplicity

Fewer moving parts means less to go wrong, and theoretically makes it easier to understand how everything fits together. This is overridden by the principle of modularity and in cases where there is a conflict, modularity takes priority. This principle also informs the choice of dependencies - where more than one choice exists, those which work smoothly and easily are favoured over those that give trouble, require a lot of fiddling to get right, are badly documented, or otherwise troublesome.


### Modernity

The most modern technologies possible should be used, provided they are sufficiently stable and proven. This is overridden by the other principles, so any choice of technology that detracts from the practicality, modularity or simplicity of the project will probably find itself losing out to a less modern alternative that does not share these problems.


## Directories


### build

This is where all built files end up. Don't track anything inside this directory in source control as it will be deleted and re-generated on every rebuild.


### config

Configuration files that differ between workflows (eg. dev/production) live in this directory. It's important to note that any configs that do NOT vary are normally found in the root directory instead.


### node-scripts

Contains custom node.js scripts which perform certain parts of the workflow tasks eg. generating icon fonts.


### resources

Convenience directory for raw assets that don't really belong in `src` but which need to be tracked in source control, eg. source files such as excel spreadsheets containing copy, uncompressed image assets, etc.


### src

The main source directory where source code lives. Contains assets such as fonts and images, as well as HTML, javascript and CSS source files.


### temp

This directory is automatically generated by the setup scripts and contains intermediate files required during the build process (eg. font-face CSS for the icon fonts and webfonts). Nothing in here should be committed into source control.


## Build scripts

Rather than using a task runner (eg. Grunt, Gulp) this boilerplate uses a series of NPM scripts, which can be found in the package.json. These perform the various tasks forming workflows and build steps. Scripts are named using a convention of names separated by semicolons, with the first name representing the high-level task the script performs all or part of (eg. "setup", "make", "clean"), the second being the subdivision of that task which the script performs, and so on as more subdivisions of tasks occur. The tasks aim to be sub-divided in such a way that they are as modular as possible.


### setup

Runs a sequence of scripts which performs a full installation and setup of the boilerplate ready for use.


#### setup:bp

Exists to enable the setup scripts to be easily re-run without invoking NPM to reinstall deps.


#### setup:mkdirs

Creates directories required by the boilerplate, but which don't need to be recreated each time, or which must persist between rebuilds.


#### setup:css

Copies CSS dependencies from `node_modules` into the project source so they can be referenced.


#### make:fonts

Copies the TTF font source files from `src` to the temp directory and runs a custom node script `convert-fonts` which converts them into various webfont formats and generates font-face CSS to match.


#### make:iconfont:generate

Runs a custom node script `iconfont-generator` that takes a list of SVG files and converts them into an icon font, generating various webfont format files and a set of font-face CSS for the icons. Important to note that the listing of SVG files currently needs to be manually updated to effect the output (i.e. if you add or remove SVGs from the icon font you will need to update this list and re-run the task). Despite being part of the setup task group this can be re-run at any time when an update is required, like most of these tasks.


#### make:iconfont:sass

Runs a custom node script `map-icons` which scrapes icon styles from the generated icon font CSS and uses this to build a SASS map of all the icon char codes (this is used by the icon SASS mixin).


#### make:iconfont

Runs a sequence of scripts (`make:iconfont:generate` and `make:iconfont:sass`) to build SVG icon assets into an icon font and integrate them into the SASS ready for use.


### clean:build

Deletes any and all contents from the `build` directory.


### clean:release

Deletes any and all contents from the `release` directory.


### clean

Runs scripts responsible for cleaning directories where output files are generated.


### mkdirs

Creates required directories in the `build` directory (only necessary when tooling generating files to the `build` folder doesn't generate these for itself).


### dev

Top-level development task. This is the task you are likely to be running most of the time during development. It runs a series of sub-tasks which perform a complete build of the project (aside from one-time setup tasks), using development configurations.


#### dev:build

Development sub-task which performs the actual building tasks. This runs watch tasks on all appropriate sub-tasks, eliminating the need to re-run the task each time source code is changed.


#### copy:assets

Runs a series of sub-tasks which copy various asset files from either `src` or `temp` into the `build` directory. Sub-tasks (`copy:fonts`, `copy:webfonts`, `copy:img` and `copy:favicon`) are self-explanatory so they are not documented.


#### css:copydeps

Copies SASS `lib` files to a matching directory in `temp` to await post-processing.


#### dev:css:build

Runs `css:copydeps` and then builds CSS from SASS source files (currently uses node-sass). Output is placed in the `temp` directory to await post-processing.


#### dev:css:watch

Builds CSS from SASS source files, but also runs the watch task.


#### dev:css:post

Performs post-processing of generated CSS (currently using postcss) including polyfilling of advanced CSS features for older browsers, CSS bundling and minification, combining media queries etc. As with all other aspects of the boilerplate this should be extended as an when the need arises.


#### dev:bundle

Invokes the module bundler (in this case webpack) to build the output bundle from the source javascript. This step is also where javascript transpilation happens (currently using babel-loader for webpack), as well as any other required post-processing, and minification. Also runs the watch task.


#### dev:html

Invokes the static site generator (in this case eleventy) to build the output HTML from the layouts, templates, components and data found in the `src` directory. Currently the boilerplate is using handlebars as the templating language, but eleventy allows other popular choices such as nunjucks, liquid, markdown, pug, EJS and more. Also runs the watch task.


#### dev:serve

Starts the development server (in this case browser-sync) and begins serving the dev site on the configured port.


### prod

This task is the equivalent of the dev task, but runs everything in production mode. This is the task to run when you want to create a release build with all output assets minified and bundled for production. There is little point documenting the sub-tasks as these are the same as the matching dev equivalents, apart from obvious differences such as using a production config and not running watch tasks. One exception is the check task which isn't run as part of the dev build.


### check

Runs quality control sub-tasks to verify build output. Currently this only runs the check:js sub-task.


#### check:js

Runs quality control checks on the javascript output bundle. Currently this uses es-check to verify that the output javascript is es5 and doesn't contain un-polyfilled es6+ features (important for compatibility with rubbish but unfortunately still commonly supported browsers such as IE 11).


### prod:transform

Runs a custom node script `transform-output` which takes the contents of the output directory `build` and copies it to a release directory `release`, transforming file names, directory names and directory structure based on config data in the mapping file `transform.config.json`. This allows the output files to be re-arranged into any arbitrary structure that might be required (for example if the client requests a different output structure that is difficult or impossible to achieve with the normal workflow). It also provides a workaround for a limitation in the Eleventy static site generator which prevents it generating named HTML files (as opposed to `index.html` files in a named folder). The config format is as follows, more info can be gained by reading the script itself:

```
{
	"inputRoot": "./build/", // directory where the script looks for input files to transform
	"outputRoot": "./release/", // directory where the script writes the output files
	"items": [ // Array of items to transform. Items can represent individual files or whole directories. Only listed items are copied, so to exclude an item from the output, just don't list it.
		{
			"inPath": "my-page/index.html", // path to the input for this item. In this case the item represents a single file so inPath must point to a file.
			"outDir": "/", // output directory where the item contents will be written
			"outName": "out-page.html" // name of output file. If this is specified, the item is processed as a single file. "<inputRoot>/my-page/index.html" will be written to "<outputRoot>/out-page.html".
		},
		{
			"inPath": "css/", // In this case, the item is a directory, so inPath must point to a directory.
			"outDir": "css/" // All contents of "<inputRoot>/css/" will be written to "<outputRoot>/css/"
		},
		...
	]
}
```

At the time of writing the transform task is only available in production, because it clashes with the async watch tasks used in the dev workflow. The separate data sources for the static site generator in dev/production mode were initially implemented to support this feature, as link URLs need to differ arbitrarily between dev/prod due to the potential differences in output directory structure and file names.


## Example tasks

I thought it would be helpful to include a few examples showing how to perform certain common tasks using the boilerplate. These assume the setup steps have already been performed.


### Add a font from TTF files

1. Paste source TTF files in `src/assets/fonts`
2. Run `npm run make:fonts`. This should generate webfont files (woff, woff2 etc.) in `temp/fonts` and also CSS font-face styles in `src/sass/lib/fontfaces.css`.
3. Add or update values in the `$font-families` map inside `src/sass/_fonts.scss` to link the font to the relevant SASS mixins.
4. Start using the font (you may have to restart the dev task).


### Add a font from webfont files

If you need to use pre-built webfont files instead of TTFs, that's supported as well.

1. Paste the webfont files into `src/assets/webfonts`
2. Manually update the CSS font-face definitions in `src/sass/lib/webfontfaces.css`. Keep in mind the file paths to the assets specified in the font-face definitions need to be relative to the output CSS file (so for the default boilerplate directory structure they will take the form `../fonts/<font-file>`).
3. Add or update values in the `$font-families` map inside `src/sass/_fonts.scss` to link the font to the relevant SASS mixins.
3. Start using the font (you may have to restart the dev task).


### Add a new icon to the icon font

1. Paste the SVG asset for the new icon in `src/assets/icons`.
2. Run `npm run make:iconfont`. This will generate the icon font using the `iconfont-generator` node script, then generate SASS using the `map-icons` node script.
3. Start using the icon (it should now be present in the SASS map in `src/sass/lib/_iconmap.scss`), after which it can be referenced by name using the icon mixin.


### Add a page

1. Create a new page template `.hbs` file in `src/html/` with the name of the page (by convention these are hyphenated eg. `my-page.hbs`).
2. Enter YAML frontmatter to describe the layout file that will be used by the page, and its title.

```
---
layout: mylayout.hbs
title: My page
---
```

At this point you can also create and reference a custom layout in the `src/html/layouts` directory if you need the page to have a different HTML layout.

3. Write some HTML in the page template.
4. Create a JSON data file for the page in `src/html/data/dev` (by convention this should match the name of the page). Enter some data in JSON format. You can reference the `index` or `test` data files to see an example structure. Don't forget to also create a version in `src/html/data/prod` for the production task to use.
5. Back in the page template, use handlebars expressions to write the content from the JSON data file into the markup in the desired places. You must reference the data file by name using dot notation in the format `<data file name>.<top-level property>`, for example `{{ demo.heading }}` where "demo" is the JSON data file name, and "heading" is the top-level property in that JSON data file containing the nested content for the hero on this page.
6. Add an entry for the page in the `index.json` data file. This is not strictly required but it means a link to the page will appear on the index/listing page.
7. Run `npm run dev`. This will generate an HTML file for the page with the name `index.html` inside a directory with the name of the page. You should now be able to browse to the page from the index and view it. 


### Add a component

1. Create a new component `.hbs` file in `src/html/partials` (usually components are partials as they are reusable by definition). Partials don't require any YAML frontmatter.
2. Write some HTML in the component file.
3. Optionally create content for the component in a JSON data file (rather than having its own file this will usually be the top-level property of a page's JSON data file) and write it out in the component `.hbs` file using handlebars expressions.
4. Write out the partial inside a page `.hbs` file using a handlebars partial expression.
5. Create a SASS file in `src/sass/components` (by convention this should have the same name as the component) prefixed with an underscore eg. `_my-component.scss`.
6. Write some SASS in the file and bind it to the component using a classname. By default a BEM approach is assumed, where each component is a block, and exists in its own SASS file.
7. Include the SASS component file in the `src/sass/styles.scss` file.
8. Create a javascript file in `src/js/views` with a name matching the component `.hbs` file. Copy the contents from the template view included in the boilerplate. Views are es6 classes which extend the base view and have a common structure as follows:

```
// Example javascript component view
import BaseView from '../base-view';
import utils from '../utils';

class ExampleComponent extends BaseView {

	constructor (el) {

		const opts = {
			selectors: {
				container: '.js-example-component-container'
			},
			attributes: {
				src: 'data-video-src'
			},
			modifiers: {
				active: 'is--active'
			},
			markup: {
				embed: '<div class="example-component__embed">{{content}}</div>'
			}
		};

		super(el, opts);

		this.state = {
			active: false
		};

		this.init();
	}

	init () {

		this.getData();
		this.getElems();
		this.bindDomEvents();
	}

	getElems () {

		this.$container = this.$el.find(this.options.selectors.container);
	}

	getData () {

		for (const key in this.options.attributes) {

			this.data[key] = this.$el.attr(this.options.attributes[key]);
		}
	}

	bindDomEvents () {

		utils.bindClick(this.$container, this.handleClick.bind(this));
	}

	handleClick () {

		console.log(`ExampleComponent clicked at ${Date.now()}`);
	}
}

export default ExampleComponent;
```

9. Open the `views.js` file in `src/js` and add an import for your new view and include it in the default export, as follows:

```
...
import exampleComponent from "./views/example-component";

export default {
	...,
	exampleComponent
};

```

10. Add a `data-view` attribute on the component's outmost markup element with the name of the view, eg. `data-view="exampleComponent"` (the name should match the one inside the default export of the `views.js` file from the previous step).
11. Run `npm run dev`. An instance of the view should now be instantiated and bound to the element.


## Handlebars helpers

These can be found in the root directory in the file `handlebars-helpers.js`, which should be extended as required.


## SASS framework

The boilerplate provides a skeletal SASS framework that can be extended as required. Details can be found in comments in the relevant SASS files:

- `src/sass/_breakpoints.scss`
- `src/sass/_colours.scss`
- `src/sass/_fonts.scss`
- `src/sass/_global.scss`
- `src/sass/_grid.scss`
- `src/sass/_icons.scss`
- `src/sass/_layout.scss`
- `src/sass/_typefaces.scss`
- `src/sass/_utils.scss`


## Technologies used

Quick links to documentation for various technologies used in the boilerplate are listed here.

- Eleventy (AKA 11ty): [https://www.11ty.io/docs/](https://www.11ty.io/docs/)
- Handlebars: [https://handlebarsjs.com/](https://handlebarsjs.com/)
- Webpack: [https://webpack.js.org/concepts](https://webpack.js.org/concepts)
- Babel: [https://babeljs.io/docs/en/](https://babeljs.io/docs/en/)
- SASS: [https://sass-lang.com/documentation](https://sass-lang.com/documentation)
- PostCSS: [https://github.com/postcss/postcss/tree/master/docs](https://github.com/postcss/postcss/tree/master/docs)
- jQuery: [http://api.jquery.com/](http://api.jquery.com/)



## Known issues


### I've added or changed a font but it isn't updating in the built output

There is a known issue with some of the copying tasks where they don't overwrite files that already exist, even when they should. This will be fixed soon, as a workaround you can simply locate the offending file in the `temp` directory and delete it manually (depending which file this is it may then be necessary to re-run the `setup:bp` task afterwards to regenerate the files in question).
